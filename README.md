Перед началом (что бы синхронизироваться):
git pull


Что бы загрузить проект в GIT:
git add .
git commit -m "Исправил структуру проекта, переместил файлы"
git push

Остальные команды есть в файле, в группе, по работе с git  


**Общие указания:**

* **Язык:** Python [source: 44].
* **Основная цель:** Автоматизировать обработку аудиозаписей лекций (прием -> конвертация в текст -> анализ -> генерация документа -> возврат пользователю) [source: 2, 3].
* **Пользователи:** Преподаватели (основные), студенты (получение конспектов) [source: 9, 10].
* **Облако:** Предпочтительно Google Cloud (Storage, Speech-to-Text API, возможно AI для анализа) [sources: 13, 18, 27, 45]. Предусмотреть абстракцию для возможной смены облака [source: 54, 55].
* **Надежность:** Логирование ошибок, обработка исключений (плохое аудио, сбой API), возможность ручного перезапуска [source: 31].
* **Безопасность:** Шифрование данных, безопасное хранение ключей API и данных [source: 32].

---

**`MAI_bot/requirements.txt`**

* `pyTelegramBotAPI`: Для взаимодействия с Telegram Bot API [source: 48].
* `python-docx`: Для генерации и работы с DOCX файлами [source: 15, 50].
* `google-cloud-speech`: Клиентская библиотека Google Cloud Speech-to-Text API [source: 18, 45].
* `google-cloud-storage`: Клиентская библиотека Google Cloud Storage [source: 13, 45].
* *Возможно:* `google-cloud-aiplatform` (или аналоги): Если анализ текста (конспект, проверка галлюцинаций) будет делаться через Google AI/Gemini [source: 45, 64].
* *Возможно:* Библиотека для рендеринга LaTeX в изображение (например, `matplotlib` или специализированная): Если нужна поддержка формул [source: 53].
* *Возможно:* Библиотека для конвертации DOCX/RTF в PDF (например, `docx2pdf`, `libreoffice-convert` или через `pandoc`). [source: 5, 42, 51].
* *Возможно:* `python-dotenv`: Если конфигурация будет храниться в `.env` файле.

---

**`MAI_bot/config.py` (или переменные для `.env`)**

* `TELEGRAM_BOT_TOKEN`: Токен для доступа к Telegram Bot API.
* `GOOGLE_APPLICATION_CREDENTIALS`: Путь к файлу ключа сервисного аккаунта Google Cloud или другие данные для аутентификации.
* `GCS_BUCKET_NAME`: Имя бакета в Google Cloud Storage для хранения файлов.
* *Возможно:* `TEMP_FOLDER_PATH`: Путь к папке для временных файлов (`temp/`).
* *Возможно:* `LOG_LEVEL`, `LOG_FILE_PATH`: Настройки логирования.
* **Важно:** Обеспечить безопасность хранения этих данных [source: 32].

---

**`MAI_bot/main.py`**

* Инициализация бота (используя токен из `config`).
* Настройка логирования (вызов функции из `utils`).
* Регистрация обработчиков сообщений и команд из `telegram_handler`.
* Запуск основного цикла бота (polling или webhook).
* Определение и координация основной последовательности действий при получении файла [source: 35]:
    1.  Получение аудио от `telegram_handler`.
    2.  (Опционально) Сохранение во временную папку (`temp/`).
    3.  Вызов `cloud_storage` для загрузки оригинала аудио в облако.
    4.  Вызов `audio_processor` для конвертации аудио в текст.
    5.  Вызов `cloud_storage` для загрузки транскрипта в облако.
    6.  Вызов `text_analyzer` для анализа транскрипта (генерация конспекта, поиск проблем).
    7.  Вызов `doc_generator` для создания итоговых документов (DOCX, TXT, RTF, PDF).
    8.  (Опционально) Вызов `cloud_storage` для загрузки итоговых документов.
    9.  Вызов `telegram_handler` для отправки документов пользователю.
    10. (Опционально) Очистка временных файлов.

---

**`MAI_bot/app/__init__.py`**

* Может быть пустым.

---

**`MAI_bot/app/telegram_handler.py`**

* Импортировать `telebot` из `pyTelegramBotAPI`.
* Инициализировать объект бота (получая его из `main` или создавая здесь с токеном из `config`).
* Определить обработчики (`@bot.message_handler(...)`):
    * На команды `/start`, `/help`.
    * На получение сообщений с типом `content_types=['audio', 'document']`. Убедиться, что принимаются аудиофайлы [source: 16], желательно проверять MIME-типы или расширения (mp3, wav и т.д.) [source: 17].
* Функция для скачивания полученного аудиофайла (например, во временную папку).
* Функция для отправки текстовых сообщений пользователю (статус обработки, ошибки) [source: 34].
* Функция для отправки сгенерированных файлов документов пользователю (DOCX, PDF, TXT, RTF) [sources: 5, 26].
* Взаимодействие с `main` или другими модулями для запуска процесса обработки и получения результата.

---

**`MAI_bot/app/audio_processor.py`**

* Импортировать `google.cloud.speech`.
* Функция `transcribe_audio(audio_file_path_or_gcs_uri)`:
    * Принимает путь к локальному аудиофайлу или GCS URI.
    * Инициализирует клиент Speech-to-Text API (аутентификация через `GOOGLE_APPLICATION_CREDENTIALS`).
    * Настраивает конфигурацию распознавания (`RecognitionConfig`): язык (`ru-RU`), модель (можно указать конкретную), формат аудио (если известен). Обработка различных форматов [source: 17].
    * Настраивает объект аудио (`RecognitionAudio`) - либо с локального файла, либо с GCS URI.
    * Вызывает метод API для распознавания (например, `recognize` для коротких файлов или `long_running_recognize` для длинных лекций) [source: 19].
    * Обрабатывает ответ API, извлекает текстовый транскрипт.
    * Обрабатывает возможные ошибки API или случаи пустого результата [source: 31].
    * Возвращает строку с транскриптом.

---

**`MAI_bot/app/cloud_storage.py`**

* Импортировать `google.cloud.storage`.
* (Опционально) Определить базовый класс/интерфейс для абстракции хранилища [source: 54].
* Класс `GoogleCloudStorageHandler` (или аналогичный):
    * Инициализация клиента GCS (аутентификация, имя бакета из `config`).
    * Метод `upload_file(source_file_path, destination_blob_name)`: загружает локальный файл в бакет [sources: 4, 20, 36]. `destination_blob_name` должен быть уникальным [source: 21].
    * Метод `get_gcs_uri(blob_name)`: возвращает GCS URI для загруженного файла (вида `gs://bucket-name/blob-name`).
    * *Возможно:* Метод `download_file(blob_name, destination_file_path)`.
    * Обработка ошибок при взаимодействии с GCS.

---

**`MAI_bot/app/text_analyzer.py`**

* Функция `analyze_transcript(transcript_text)`:
    * Принимает текст транскрипта.
    * Реализует логику анализа:
        * **Генерация конспекта:** Выделение ключевых моментов/тезисов лекции [sources: 4, 22, 23]. Это может потребовать использования LLM (например, Google Gemini через API [source: 64]) или других NLP-техник (суммаризация текста).
        * **Выявление проблемных мест:** Поиск потенциальных ошибок распознавания или "галлюцинаций" ИИ для последующей проверки преподавателем [sources: 14, 25, 63, 66]. Это тоже может быть задачей для LLM или статистических методов.
    * Возвращает структурированный результат: например, словарь `{'summary': '...', 'verification_points': ['...', '...']}`.

---

**`MAI_bot/app/doc_generator.py`**

* Импортировать `docx` из `python-docx`.
* *Возможно:* Импортировать утилиты для рендеринга LaTeX и конвертации в PDF.
* Функция `create_documents(analysis_results, lecture_meta)`:
    * Принимает результаты анализа из `text_analyzer` и метаданные лекции (название, дата - нужно продумать, откуда их брать).
    * **Создание DOCX:**
        * Создает новый документ `docx.Document()`.
        * Добавляет заголовки, параграфы с описанием лекции, сгенерированным конспектом (`analysis_results['summary']`) [source: 24].
        * Добавляет раздел с методическими указаниями / пунктами для проверки (`analysis_results['verification_points']`) [source: 25].
        * *Если нужна поддержка LaTeX:* Рендерит формулы в изображения (используя функцию из `utils`) и вставляет их в документ (`document.add_picture(...)`) [source: 53].
        * Сохраняет DOCX файл (например, во временную папку).
    * **Создание TXT/RTF:**
        * Извлекает текстовое содержимое из созданного DOCX или напрямую из `analysis_results` и сохраняет в `.txt` и/или `.rtf` файлы [sources: 5, 41, 50]. Форматирование в RTF потребует дополнительной логики или библиотек.
    * **Создание PDF:**
        * Конвертирует созданный DOCX (или RTF) в PDF [sources: 5, 42, 51].
    * Возвращает пути к созданным файлам (DOCX, TXT, RTF, PDF).

---

**`MAI_bot/app/utils.py`**

* Функция `setup_logging()`: Настраивает логирование (уровень, формат, вывод в файл/консоль) согласно настройкам в `config` [sources: 28, 43, 47].
* *Возможно:* Классы кастомных исключений для обработки специфичных ошибок приложения.
* *Возможно:* Функции для работы с временными файлами (генерация уникальных имен, безопасное удаление).
* *Возможно:* Функция `render_latex_to_image(latex_string)`: Принимает строку LaTeX, рендерит ее в изображение (используя `matplotlib` или др.), возвращает путь к файлу изображения [source: 53].

---

**`MAI_bot/tests/__init__.py`**

* Может быть пустым.

---

**`MAI_bot/tests/test_*.py`**

* Использовать `unittest` или `pytest`.
* Написать тесты для каждого модуля в `app/`:
    * `test_audio_processor.py`: Протестировать функцию транскрибации, используя mock для Google Speech API. Проверить обработку ошибок API.
    * `test_cloud_storage.py`: Протестировать загрузку/скачивание, используя mock для Google Storage API.
    * `test_text_analyzer.py`: Протестировать логику анализа (если возможно без внешних LLM) или протестировать взаимодействие с mock LLM API.
    * `test_doc_generator.py`: Протестировать создание структуры DOCX с заданными данными. Проверить создание TXT/RTF/PDF (если реализовано). Проверить вставку изображений (если есть LaTeX).
    * `test_telegram_handler.py`: Протестировать обработчики команд и сообщений (сложно без mock-фреймворка для telebot, но можно тестировать внутреннюю логику функций).
* Написать интеграционные тесты, проверяющие цепочку вызовов между модулями (например, от получения файла до генерации документа), используя mock для внешних сервисов (Telegram, Google API) [source: 58].

---

**`MAI_bot/.gitignore`**

* `.venv/`
* `venv/`
* `__pycache__/`
* `*.pyc`
* `.idea/` # Для PyCharm
* `temp/` # Папка для временных файлов
* `*.log` # Лог файлы
* `.env` # Если используется для секретов
* `config.py` # Если содержит секреты и НЕ используется .env
* `.DS_Store` # Для macOS

---

**`MAI_bot/README.md`**

* Название проекта.
* Краткое описание цели и функциональности [source: 1.1, 1.2].
* Инструкции по установке:
    * Клонирование репозитория.
    * Создание и активация виртуального окружения (`python -m venv .venv`, `source .venv/bin/activate`).
    * Установка зависимостей (`pip install -r requirements.txt`).
* Инструкции по настройке:
    * Как получить и куда поместить токен Telegram бота.
    * Как получить и настроить учетные данные Google Cloud (`GOOGLE_APPLICATION_CREDENTIALS`).
    * Описание файла `config.py` или `.env` и его переменных.
* Инструкции по запуску: `python main.py`.
* Краткое описание архитектуры (модули и их назначение) [source: 2.2].
* Инструкции по запуску тестов (например, `pytest`).